---
title: '네트워크 정리'
date: '2025-04-29'
desc: '네트워크 정리 - 네트워크계층, TCP/UDP, HTTP, REST'

---

## 네트워크 계층

### OSI 7계층

네트워크 통신이 이루어지는 과정을 7단계로 나눈 네트워크 표준 모델

[7] 응용계층: HTTP 등의 프로토콜을 프로그램의 UI 통해 제공<br/>
[6] 표현계층: 데이터를 표준화된 형식으로 변경<br/>
[5] 세션계층: 세션 유지 및 해제 등 통신 제어와 동기화 진행<br/>
[4] 전송계층: TCP/UDP와 같은 전송방식과 포트번호 결정<br/>
[3] 네트워크 계층: 최적 경로 선택하는 라우팅 수행<br/>
[2] 데이터 링크 계층: 데이터 흐름 관리, 데이터의 오류 검출 및 복구 수행<br/>
[1] 물리계층 : 데이터를 비트 단위의 0과 1로 변환 후 전송/전기 신호를 데이터로 복원

- 각 계층은 독립적으로 동작
- 데이터 캡슐화: 데이터를 송신할때 각 계층에서 필요 정보 추가해 데이터 가공 → 헤더와 트레일러 붙임 → 수신부의 같은 계층에서 데이터 호환성 높이기 위함
- 데이터 역캡슐화: 받은 데이터에서 헤더와 트레일러 분석해 제거

### TCP/IP 4계층

TCP/IP: 인터넷에서 데이터를 주고받기 위한 네트워크 프로토콜

- TCP: 데이터를 나눈 단위인 패킷의 전달 여부와 전송 순서 보장하는 통신 방식
- IP: 패킷을 빠르게 보내기 위한 통신 방식

TCP/IP 4계층: OSI 7계층을 단순화 한 것

[4] 응용 계층: 사용자와 소프트웨어 연결, HTTP/HTTPS/DNS<br/>
[3] 전송 계층: 데이터 신뢰성 보장, 포트번호로 데이터를 적절한 응용 프로그램에 전달, TCP/UDP, 전송 계층의 데이터 단위는 세그먼트<br/>
[2] 인터넷 계층: 데이터를 최종 목적지까지 도달할 수 있게 함, IP는 데이터그램 단위로 패킷 전달을 담당하며 라우팅과 주소 지정 기능을 수행<br/>
[1] 네트워크 인터페이스 계층: 데이터를 전기 신호로 변환하고 MAC 주소를 사용해 기기에 데이터 전달

## TCP와 UDP

### TCP

- 송신부와 수신부의 연결을 확인하는 연결형 서비스
- 가상 회선 방식
  - 데이터를 주고받기 전, 패킷을 전송할 경로인 가상 회선을 설정해 모든 패킷을 같은 경로로 전송
- 패킷의 전송 순서 보장
- 패킷의 수신 여부 확인
- 데이터 손실 없음 보장 → 신뢰성 높음
- 데이터의 송수신 속도 느림
- 송신부와 수신부의 1:1 통신

### TCP 핸드셰이킹

연결형 서비스 지원을 위해 송신부와 수신부를 연결하는 과정<br/>
연결을 시작할 때는 3-way 핸드셰이킹, 연결을 종료할 때는 4-way 핸드셰이킹 수행<br/>
이 과정에서 연결 제어 및 관리를 위해 플래그 값을 주고받음

- SYN(synchronization): 연결 생성 시 사용
- FIN(finish): 연결 끊을 때 사용
- ACK(acknowledgement): 데이터를 전송하면 수신자가 받았음을 알려줄 때 사용
- RST(reset): 연결 재설정 시 사용
- PSH(push): 빠른 응답이 필요한 데이터 즉시 전송 시 사용
- URG(urgent): 다른 데이터보다 우선순위가 높은 데이터 전송 시 사용

**🌟 3-way 핸드셰이킹**

데이터를 주고받기 전, 송신자와 수신자의 세션을 수립하는 과정

1. 송신부 -- SYN(N) --> 수신부
   - 송신부는 응답이 오기 전까지 **SYN_SENT** 상태
2. 송신부 &lt;-- ACK(N+1) + SYN(M) -- 수신부
   - 수신부는 **SYN_RECEIVED** 상태
   - 송신부가 ACK+SYN 메세지 받으면 **ESTABLISHED** 상태 됨
3. 송신부 -- ACK(M+1) --> 수신부
   - 수신부는 메세지 받고 **ESTABLISHED** 상태 됨

**🌟 4-way 핸드셰이킹**

TDP 연결 해제하기 위한 과정

1. 송신부 -- FIN --> 수신부
   - 송신부는 **FIN_WAIT1** 상태
2. 송신부 &lt;-- ACK -- 수신부
   - 수신부는 **CLOSE_WAIT** 상태 + 연결 종료 위한 작업 시작
   - 송신부는 메세지 받고 **FIN_WAIT2** 상태
3. 송신부 &lt;-- FIN -- 수신부
   - 수신부는 **LAST_ACK** 상태
4. 송신부 -- ACK --> 수신부
   - 송신부는 **TIME_WAIT** 상태 → 일정 시간 지나면 **CLOSED** 상태 됨
     - FIN 메세지 전에 보낸 패킷이 FIN 메세지 보다 지연되어 발생하는 패킷 유실 대비
     - 수신부에 ACK 메세지 전달되지 않아 연결 해제 이뤄지지 않는 경우 대비
   - 수신부는 메세지 받고 **CLOSED** 상태

**🌟 TCP Keep Alive**

- 세션이 연결되면 이를 유지하기 위해 일정 시간 경과 후 TCP Keep Alive 패킷 던져 유지 상태 확인
- 연결 유지 원하는 쪽에서 보냄 / 응답을 받으면 시간 처음부터 다시 측정, 응답 받지 못하면 연결 종료
- → 동일한 송신부로부터 재요청 오는 경우 불필요한 3-way 핸드셰이킹 줄임
- → FIN메세지 받지 못한 경우 발생할 수 있는 불필요한 연결(좀비커넥션) 방지

### TCP 제어 방법

**🌟 흐름제어**

데이터 송신부와 수신부에서 데이터 처리 속도 차이 때문에 생기는 데이터 손실 방지

1. **정지-대기(stop-wait)**

- 데이터 보낸 후 ACK 메세지 받을 때까지 다음 데이터 보내지 않고 기다림
- 일정 시간 동안 ACK 메세지 받지 못하면 패킷 재전송
- 시간 면에서 비효율적

2. **슬라이딩 윈도우(sliding window)**

- 수신부에서 설정한 윈도우 크기만큼 데이터를 연속적으로 보낼 수 있게 해 데이터 흐름 동적 제어
- 윈도우 크기: 응답 받지 않고 보낼 수 있는 데이터의 최대 개수, 3-way 핸드셰이킹 과정에서 정해짐
- 윈도우 크기 N일때, n번부터 n+N-1번 데이터까지 송신한 상태에서 n번 데이터에 대해 ACK 메세지 받으면 n+N번 데이터 보낼수 있음

**🌟 혼잡제어**<br/>

송신부의 데이터 전달 속도와 네트워크 속도 차이로 데이터 손실 발생 방지<br/>
혼잡은 네트워크에 패킷 수가 과도하게 증가하는 증상을 의미하며, TCP는 혼잡 윈도우 크기 조절해 혼잡에 대응

1. **AIMD(Additive Increase Multiplicative Decrease)**

- 데이터 전달 시 합 증가 방식으로 혼잡 윈도우 크기 더해가며 키움(선형 증가)
- 데이터 손실 발생 시 혼잡 윈도우 크기를 곱 감소 방식을 적용해 배수 단위로 줄임(지수 감소)
- 데이터 유실 발생하면 증가폭 대비 감소폭이 크기 때문에 네트워크 넓게 사용하기까지 시간이 오래걸림

2. **느린 시작(slow start)**

- 윈도우 크기가 1인 상태에서 시작해 ACK 수신할 때마다 윈도우 크기 지수 함수 형태로 증가
- 혼잡 발생 시 윈도우 크기 1로 줄임

3. **혼잡 회피(congestion avoidance)**

- 윈도우 크기에 대한 임계점 정하는 방식
- 윈도우 크기를 지수 함수 형태로 증가 시키다가, 윈도우 크기가 임계점에 도달하면 윈도우 크기를 선형적으로 증가하게 함
- ACK 메세지 받지 못해 타임아웃 발생하면 윈도우 크기의 절반을 임계점으로 설정, 윈도우 크기를 초기값으로 변경

4. **빠른 회복(fast recovery)**

- 혼잡 발생 시 혼잡 윈도우 크기를 절반으로 줄인 후 선형적으로 증가하는 방식
- 혼잡이 처음 발생하면 AIMD 방식으로 동작

5. **빠른 재전송(fast retransmit)**

- Duplicate ACK가 3번 발생하면 해당 시점의 윈도우 크기를 1/2로 줄임
- Duplicate ACK: 패킷이 순서대로 도착하지 않아 받아야 할 차례의 패킷을 ACK 메세지와 함께 요청, 3번 발생 시 혼잡이 발생했다고 판단

**🌟 TCP 혼잡제어 정책**<br/>

1. **TCP Tahoe(타호)**

- 느린 시작 사용해 혼잡 윈도우 크기를 지수적으로 키움, 임계점 넘어가면 AIMD 방식으로 전환(선형 증가)
- 혼잡 발생 시 혼잡이 발생한 윈도우 크기의 절반을 임계점(ssthresh)으로 설정, 혼잡 윈도우 크기 1로 초기화

2. **TCP Reno(레노)**

- 초반에는 느린 시작 사용, 임계점 넘어가면 AIMD 방식으로 전환(선형 증가)
- 3 Duplicate ACK 발생 시: 혼잡 윈도우 크기 절반으로 줄이고, 줄인 혼잡 윈도우 크기를 임계점(ssthresh)으로 설정
- 타임아웃 발생 시: 혼잡 윈도우 크기를 1로 초기화, 임계점(ssthresh) 값 변경 X

**🌟 오류제어**<br/>

데이터에 오류 또는 유실이 발생할 때 데이터의 신뢰성을 보장하기 위해 오류를 제어하는 방식

데이터에 오류 또는 유실이 발생함을 인지하는 경우

- 수신부에서 잘못된 데이터 받았다는 NAK 메세지 보낸 경우
- 3 Duplicate ACK
- 수신부로부터 ACK 메세지 받지 못해 타임아웃 발생

1. **정지-대기**

- 타임아웃 발생 시 해당 패킷 다시 보내는 방식

2. **Go-Back-N ARQ**

- 누락 데이터 있으면 송신부에서 해당 데이터 이후 모든 패킷 재전송
- 0\~2 패킷을 보내고 ACK 3 메세지를 받으면 패킷 3부터 다시 보냄 / 3\~5 패킷 보내고 ACK 4 메세지 받으면 패킷4, 5 재전송

3.  **Selective-Repeat ARQ**

- 누락 데이터 있으면 수신부에서 해당 데이터만 재전송 요청
- 0\~2 패킷 잘 수신하면 ACK 3 메세지를 보냄 / 3\~5 패킷 보냈을때 패킷 4 받지 못했다면 패킷 4 보내라는 의미로 ACK 4 메세지 보냄 / 패킷 4 받으면, 패킷 6 요청
- 특정 패킷만을 전송한다는 효율성이 있지만, 받은 패킷을 재정렬하는 로직이 추가적으로 필요

### UDP

- 송신부와 수신부의 연결 보장되지 않는 비연결형 서비스
- 데이터그램 패킷 교환 방식
  - 패킷마다 최적의 경로로 전송되는 방식
  - 보낸 패킷의 순서와 도착하는 패킷의 순서가 다를 수 있음
- 패킷의 수신 여부 확인하지 않음
- 1:1, 1:N, N:N 통신
- 데이터의 신뢰성 낮음
- 데이터의 전송 속도 빠름

### UDP 오류 검출

- 최소한의 신뢰성 보장을 위해 체크섬(checksum) 방식으로 오류 검출
- 체크섬을 만들기 위한 데이터를 모두 더하고, 오버플로되는 캐리가 발생하면 해당 캐리를 떼서 데이터에 다시 더한 후 1의 보수 취해 체크섬 만듦
- 체크섬을 이용해도 오류 100% 검출할 수 있는 것 아님
- 선택 사항으로, 송신부에서 체크섬 값을 0으로 보내면 수신부는 체크섬 계산하지 않음

## HTTP

### HTTP

인터넷상에서 데이터를 전송하기 위한 프로토콜

**비연결성**

- 클라이언트에서 요청 보낸 후 서버로부터 응답 받으면 연결 끊음
- 연결 유지하지 않음으로써 자원 아낌
- 서버가 클라이언트를 기억할 수 없어 동일 클라이언트의 연속적인 요청에 대해 연결, 연결 해제 반복 → 자원 낭비
  - → 일정 시간 동안 연결 유지할 수 있도록 **HTTP Keep Alive** 사용
  - → 마지막 응답 이후 일정 시간동안 연결 유지해 동일 클라이언트의 재요청에 대해 연결 과정 생략

**무상태**

- 서버에서 클라이언트의 상태 저장하지 않음
- 클라이언트는 요청에 필요한 데이터를 모두 가지고 있거나, 서버가 클라이언트로부터 받은 요청 사항 모두 저장해야함
  - 쿠키: 클라이언트 로컬에 저장되는 키와 값이 들어 있는 작은 데이터 파일
  - 세션: 서버에 저장되는 연결 관련 정보
- 서버 확장성이 높음, 요청에 응답하는 서버가 바뀌어도 되기 때문에 서버를 계속 확장해도 됨

**🌟 HTTP 메세지**

클라이언트와 서버가 통신하기 위해 주고받는 정형화된 데이터

- request line: 요청 URI, 요청 방법, HTTP 버전 등 포함
- status line: 요청에 대한 HTTP 상태 코드, HTTP 버전 포함
- header: 키-값으로 구성된 헤더 항목으로 구성
- blank: 헤더의 끝을 나타내는 빈 줄, 헤더와 바디 구분
- body: POST인 경우에만 바디가 있고, 그 외는 비어 있는 상태로 전달

**🌟 HTTP 상태코드**

- 1xx: 클라이언트로부터 요청 받아 처리 중
- 2xx: 요청 성공적으로 처리
  - 200: 요청 성공적으로 처리함
- 3xx: 요청 처리 위해 추기 처리 필요
- 4xx: 클라이언트 오류
  - 401: 인증되지 않음
  - 403: 접근 실패
  - 404: 클라이언트에서 요청한 자원 찾지 못함
- 5xx: 서버 오류
  - 500: 서버 내부 오류 발생

### HTTPS

보안 계층인 SSL/TLS 이용해 HTTP의 보안 강화한 웹 통신 프로토콜<br/>
데이터를 송신할 때 보안 계층에서 데이터를 암호화해 전송 계층으로 전달, 수신할 때 보안계층에서 데이터 받아 복호화 후 응용 계층으로 전달

**🌟 암호화방식**

- 대칭 키 암호화 방식
  - 데이터의 암호화와 복호화에 같은 키인 대칭 키 사용
  - 수신자가 가진 키를 송신자에게 전달, 수신자가 같더라도 송신자가 다르면 키 다름
  - 송신자는 받은 키로 데이터 암호화 후 보냄, 수신자는 동일 키로 데이터 복호화
  - 대칭 키 유출에 주의해야 함
- 공개 키 암호화 방식
  - 암호화와 복호화를 다른 키로 하는 방식
  - 암호화할 때는 공개 키, 복호화할 때는 비밀 키 사용
  - 수신자는 공개 키 클라이언트에게 제공, 클라이언트 달라도 공개 키 같음
  - 송신자는 받은 키로 데이터 암호화, 수신자는 비밀 키로 데이터 복호화
  - 비밀 키가 있어야만 복호화 가능해 공개 키 유출 염려하지 않아도 됨

### 웹페이지 접속 과정

1. 사용자가 URL을 웹 브라우저에 입력한다.
2. 웹 브라우저는 입력한 URL을 바탕으로 DNS 서버에 연결할 IP를 요청한다.
3. DNS 서버는 IP 주소를 웹 브라우저에 응답으로 제공한다.
4. 웹 브라우저는 DNS 서버에서 받은 IP를 통해 웹 서버와 TCP/IP 연결을 하고 HTTP 요청을 보낸다.
5. 웹 서버는 받은 HTTP 요청에 응답한다. 응답은 웹 페이지와 필요한 리소스를 포함한다.
6. 웹 브라우저는 받은 응답을 바탕으로 사용자에게 웹 페이지를 보여준다.

## REST

- HTTP 통신 활용을 위해 고안된 아키텍처
- URI로 자원을 명시하고 HTTP 메서드로 CRUD 연산을 하는 소프트웨어 아키텍처
- HTTP 프로토콜을 사용하므로 별도 인프라 구축 필요 없음, HTTP 프로토콜 따르는 모든 플랫폼에서 사용할 수 있음

### REST API

REST를 기반으로 한 API

1. 클라이언트가 URI로 식별한 자원에 대해 HTTP 메서드를 사용해 REST API로 요청
2. REST API가 HTTP 요청 메세지에 실려 서버에 전달됨
3. 서버에서는 수신한 HTTP 요청 메세지를 바탕으로 요청 사항을 확인 후 처리, HTTP 응답 반환
4. 응답 메세지는 자원에 대한 정보를 JSON/XML 등의 형태로 포함, 클라이언트는 해당 형태의 정보 수신

### HTTP 메서드

- POST: 데이터 생성(Create)
- GET: 데이터 조회(Read)
- PUT: 데이터 갱신(Update)
- DELETE: 데이터 제거(Delete)
